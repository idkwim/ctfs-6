# [Internetwache CTF 2016](https://ctf.internetwache.org/) : Remote Printer

**Category:** Exploit
**Points:** 80
**Solves:** 101
**Description:**

> Description: Printer are very very important for offices. Especially for remote printing. My boss told me to build a tool for that task.
>
>
> Attachment: [exp80.zip](./exp80.zip)
>
>
> Service: 188.166.133.53:12377


## writeup

This is a [classical format string vulnerability](https://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf).
Unfortunately the remote service is down now (after the competition),
but the server binary `RemotePrinter` is available in the
challenge [ZIP](./exp80.zip).

Observing the server binary, it is a general ELF 32-bit binary without
any security feature (like NX, RELRO, canary, PIE) enabled.
Experimenting with it (e.g. with `ltrace`), the server
asks for an IP address and a port, it tries to open a socket
connection to that IP and port, tries to receive some bytes to its
buffer, and outputs the buffer with `printf`.

### vulnerability

Disassembling the binary (e.g. with
[radare2](https://github.com/radare/radare2),
it can be found easily that this `printf` call has only the
buffer as arg, so here is that classical format string vulnerability.
As a PoC a `%08x` can be send to the server to print.

So for testing locally the following steps are required:

1. Set up a listener (client) on localhost: `nc -nvlp 3000 -s 127.0.0.1`
2. Launch the `RemotePrinter` server locally.
3. Enter address `127.0.0.1` and port number `3000` according to the listener
4. The connection should open.
5. Write PoC payload `%08x` to the listener (client)
6. The server should print a hex address (e.g. `ffb5613c` or something like that).

Of course, this should work with remote service as well, change
the client listener IP to a public address (or setup a port forward
in case of behind a NAT), and connect to the remote service
with e.g. `nc 188.166.133.53 12377` instead of launching `RemotePrinter`
locally. (The remote service is down now, after the competition.)

### exploit

Exploiting the format string vulnerability with `%n` payloads allows
writing to arbitrary memory addresses. Somehow taking control of the
execution flow is needed. Disassembling the binary reveals that
after that vulnerable `printf` call there is a call to `close`.
Because there is no full
[RELRO](http://tk-blog.blogspot.hu/2009/02/relro-not-so-well-known-memory.html)
enabled, Global Offset Table can
be rewritten. Changing `close@got.plt` takes over the execution flow.

Note, that there is no need to inject shellcode or do something
more complex. There exists a hidden, unused function in the binary
which does the job to solve challenge: it reads `flag.txt` and
dumps its content. It is located at `0x8048867`. Although there
may be
[ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization)
enabled on the remote server, it is at a fixed address
because there is no
[PIE](https://en.wikipedia.org/wiki/Position-independent_code)
in the binary. Despite this, the address
of the function can be calculated by leaking a text section address
from the stack.

The `close@got.plt` entry has `0x80485c6`, the flag.txt reader
function is at `0x8048867`, so only the low two bytes need to
be rewritten to `0x8867`. This can be achieved by a `%hn` format
string. The payload `AAAA%7$08x` gives `41414141`, so the
final payload hijacking the execution flow to the flag.txt reader
should be `AAAA%11111x%7$hn`, where `AAAA` is the LE address of
`close@got.plt` and `11111` should be a suitable number to
write exactly `8867` to the address of `close@got.plt`.
It can be calculated by one experiment run with `gdb`:
it should be `34915`.

The exploit that is doing everything automatically in Python (using
the awesome [pwntools framework](http://pwntools.com/))
is [here](./exploit_remoteprinter.py).

The flag from the competition remote service is:
```
IW{YVO_F0RmaTt3d_RMT_Pr1nT3R}
```
